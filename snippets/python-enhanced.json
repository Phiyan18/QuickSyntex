{
  "Function with Type Hints": {
    "prefix": "deft",
    "body": [
      "def ${1:function_name}(${2:parameter}: ${3:type}) -> ${4:return_type}:",
      "    \"\"\"${5:Function description}",
      "    ",
      "    Args:",
      "        ${2:parameter} (${3:type}): ${6:Parameter description}",
      "    ",
      "    Returns:",
      "        ${4:return_type}: ${7:Return description}",
      "        ",
      "    Raises:",
      "        ${8:ExceptionType}: ${9:When this exception is raised}",
      "    \"\"\"",
      "    ${0:pass}"
    ],
    "description": "Function definition with comprehensive type hints and docstring"
  },

  "Class with Type Hints": {
    "prefix": "classt",
    "body": [
      "from typing import ${1:Optional, List, Dict}",
      "",
      "class ${2:ClassName}:",
      "    \"\"\"${3:Class description}",
      "    ",
      "    Attributes:",
      "        ${4:attribute} (${5:type}): ${6:Description}",
      "    \"\"\"",
      "    ",
      "    def __init__(self, ${7:parameter}: ${8:type}) -> None:",
      "        \"\"\"Initialize ${2:ClassName}",
      "        ",
      "        Args:",
      "            ${7:parameter} (${8:type}): ${9:Parameter description}",
      "        \"\"\"",
      "        self.${4:attribute}: ${5:type} = ${7:parameter}",
      "    ",
      "    def __str__(self) -> str:",
      "        \"\"\"String representation of ${2:ClassName}\"\"\"",
      "        return f\"${2:ClassName}(${4:attribute}={self.${4:attribute}})\"",
      "    ",
      "    def __repr__(self) -> str:",
      "        \"\"\"Developer representation of ${2:ClassName}\"\"\"",
      "        return self.__str__()",
      "        ",
      "    ${0:pass}"
    ],
    "description": "Class definition with type hints, docstrings, and magic methods"
  },

  "Dataclass": {
    "prefix": "dataclass",
    "body": [
      "from dataclasses import dataclass",
      "from typing import ${1:Optional, List, Dict}",
      "",
      "@dataclass",
      "class ${2:ClassName}:",
      "    \"\"\"${3:Class description}",
      "    ",
      "    Attributes:",
      "        ${4:attribute}: ${5:Description}",
      "    \"\"\"",
      "    ${4:attribute}: ${6:type}",
      "    ${7:optional_attr}: ${8:Optional[type]} = None",
      "    ",
      "    def __post_init__(self) -> None:",
      "        \"\"\"Post-initialization processing\"\"\"",
      "        ${0:pass}"
    ],
    "description": "Dataclass with type hints and post-init method"
  },

  "Context Manager": {
    "prefix": "context",
    "body": [
      "from typing import ${1:Any, Optional}",
      "from contextlib import contextmanager",
      "",
      "class ${2:ContextManagerName}:",
      "    \"\"\"${3:Context manager description}\"\"\"",
      "    ",
      "    def __init__(self, ${4:parameter}: ${5:type}) -> None:",
      "        self.${4:parameter} = ${4:parameter}",
      "        self.${6:resource}: ${7:Optional[type]} = None",
      "    ",
      "    def __enter__(self) -> '${2:ContextManagerName}':",
      "        \"\"\"Enter the context manager\"\"\"",
      "        # Acquire resource",
      "        ${8:# self.resource = acquire_resource()}",
      "        return self",
      "    ",
      "    def __exit__(self, exc_type, exc_val, exc_tb) -> None:",
      "        \"\"\"Exit the context manager\"\"\"",
      "        # Release resource",
      "        ${9:# if self.resource:}",
      "        ${10:#     release_resource(self.resource)}",
      "        ${0:pass}"
    ],
    "description": "Context manager class with proper resource handling"
  },

  "Async Function": {
    "prefix": "async",
    "body": [
      "import asyncio",
      "from typing import ${1:Optional, Any}",
      "",
      "async def ${2:async_function}(${3:parameter}: ${4:type}) -> ${5:return_type}:",
      "    \"\"\"${6:Async function description}",
      "    ",
      "    Args:",
      "        ${3:parameter} (${4:type}): ${7:Parameter description}",
      "    ",
      "    Returns:",
      "        ${5:return_type}: ${8:Return description}",
      "    \"\"\"",
      "    try:",
      "        ${9:# Async operation}",
      "        result = await ${10:some_async_operation}(${3:parameter})",
      "        return result",
      "    except Exception as e:",
      "        ${11:# Handle exception}",
      "        raise",
      "    finally:",
      "        ${12:# Cleanup}",
      "        ${0:pass}"
    ],
    "description": "Async function with error handling and type hints"
  },

  "Property with Getter and Setter": {
    "prefix": "prop",
    "body": [
      "@property",
      "def ${1:property_name}(self) -> ${2:type}:",
      "    \"\"\"Get ${1:property_name}\"\"\"",
      "    return self._${1:property_name}",
      "",
      "@${1:property_name}.setter", 
      "def ${1:property_name}(self, value: ${2:type}) -> None:",
      "    \"\"\"Set ${1:property_name}",
      "    ",
      "    Args:",
      "        value (${2:type}): ${3:Value description}",
      "        ",
      "    Raises:",
      "        ValueError: ${4:When value is invalid}",
      "    \"\"\"",
      "    if ${5:validation_condition}:",
      "        raise ValueError(\"${6:Invalid value message}\")",
      "    self._${1:property_name} = value",
      "",
      "@${1:property_name}.deleter",
      "def ${1:property_name}(self) -> None:",
      "    \"\"\"Delete ${1:property_name}\"\"\"",
      "    del self._${1:property_name}",
      "    ${0:pass}"
    ],
    "description": "Property with getter, setter, and deleter methods"
  },

  "Exception Class": {
    "prefix": "exception",
    "body": [
      "class ${1:CustomException}(${2:Exception}):",
      "    \"\"\"${3:Exception description}",
      "    ",
      "    This exception is raised when ${4:condition description}.",
      "    \"\"\"",
      "    ",
      "    def __init__(self, message: str = \"${5:Default error message}\", *args) -> None:",
      "        \"\"\"Initialize ${1:CustomException}",
      "        ",
      "        Args:",
      "            message (str): Error message",
      "            *args: Additional arguments",
      "        \"\"\"",
      "        super().__init__(message, *args)",
      "        self.message = message",
      "    ",
      "    def __str__(self) -> str:",
      "        \"\"\"String representation of the exception\"\"\"",
      "        return f\"${1:CustomException}: {self.message}\"",
      "        ${0:pass}"
    ],
    "description": "Custom exception class with proper initialization"
  },

  "Comprehensive Try-Except": {
    "prefix": "trycomp",
    "body": [
      "try:",
      "    ${1:# Code that might raise exceptions}",
      "    ${2:risky_operation()}",
      "except ${3:SpecificException} as e:",
      "    ${4:# Handle specific exception}",
      "    ${5:logging.error(f\"Specific error: {e}\")}",
      "except (${6:Exception1}, ${7:Exception2}) as e:",
      "    ${8:# Handle multiple exception types}",
      "    ${9:logging.warning(f\"Multiple exception types: {e}\")}",
      "except Exception as e:",
      "    ${10:# Handle any other exception}",
      "    ${11:logging.error(f\"Unexpected error: {e}\")}",
      "    ${12:raise  # Re-raise if needed}",
      "else:",
      "    ${13:# Code to run if no exception occurred}",
      "    ${14:logging.info(\"Operation completed successfully\")}",
      "finally:",
      "    ${15:# Code that always runs}",
      "    ${0:pass}"
    ],
    "description": "Comprehensive try-except with multiple exception handling"
  },

  "Unit Test Class": {
    "prefix": "unittest",
    "body": [
      "import unittest",
      "from unittest.mock import Mock, patch, MagicMock",
      "from typing import Any",
      "",
      "class Test${1:ClassName}(unittest.TestCase):",
      "    \"\"\"Test cases for ${2:target_class}\"\"\"",
      "    ",
      "    def setUp(self) -> None:",
      "        \"\"\"Set up test fixtures before each test method\"\"\"",
      "        ${3:self.test_object = TestTargetClass()}",
      "    ",
      "    def tearDown(self) -> None:",
      "        \"\"\"Clean up after each test method\"\"\"",
      "        ${4:# Cleanup code}",
      "        pass",
      "    ",
      "    def test_${5:method_name}_success(self) -> None:",
      "        \"\"\"Test ${5:method_name} with valid input\"\"\"",
      "        # Arrange",
      "        ${6:input_value = \"test_input\"}",
      "        ${7:expected_result = \"expected_output\"}",
      "        ",
      "        # Act", 
      "        ${8:actual_result = self.test_object.method_name(input_value)}",
      "        ",
      "        # Assert",
      "        ${9:self.assertEqual(actual_result, expected_result)}",
      "    ",
      "    def test_${5:method_name}_failure(self) -> None:",
      "        \"\"\"Test ${5:method_name} with invalid input\"\"\"",
      "        # Arrange",
      "        ${10:invalid_input = None}",
      "        ",
      "        # Act & Assert",
      "        ${11:with self.assertRaises(ValueError):}",
      "            ${12:self.test_object.method_name(invalid_input)}",
      "    ",
      "    @patch('${13:module.dependency}')",
      "    def test_${5:method_name}_with_mock(self, mock_dependency: Mock) -> None:",
      "        \"\"\"Test ${5:method_name} with mocked dependency\"\"\"",
      "        # Arrange",
      "        ${14:mock_dependency.return_value = \"mocked_result\"}",
      "        ",
      "        # Act",
      "        ${15:result = self.test_object.method_name()}",
      "        ",
      "        # Assert",
      "        ${16:mock_dependency.assert_called_once()}",
      "        ${17:self.assertIsNotNone(result)}",
      "",
      "if __name__ == '__main__':",
      "    unittest.main()",
      "    ${0:pass}"
    ],
    "description": "Comprehensive unit test class with setup, teardown, and mocking"
  },

  "Decorator Function": {
    "prefix": "decorator",
    "body": [
      "from functools import wraps",
      "from typing import Callable, Any, TypeVar",
      "",
      "F = TypeVar('F', bound=Callable[..., Any])",
      "",
      "def ${1:decorator_name}(${2:param}: ${3:type} = ${4:default_value}) -> Callable[[F], F]:",
      "    \"\"\"${5:Decorator description}",
      "    ",
      "    Args:",
      "        ${2:param} (${3:type}): ${6:Parameter description}",
      "    ",
      "    Returns:",
      "        Callable: Decorated function",
      "    \"\"\"",
      "    def decorator(func: F) -> F:",
      "        @wraps(func)",
      "        def wrapper(*args, **kwargs) -> Any:",
      "            ${7:# Pre-execution logic}",
      "            try:",
      "                ${8:# Execute original function}",
      "                result = func(*args, **kwargs)",
      "                ${9:# Post-execution logic}",
      "                return result",
      "            except Exception as e:",
      "                ${10:# Error handling}",
      "                raise",
      "            finally:",
      "                ${11:# Cleanup}",
      "                pass",
      "        return wrapper  # type: ignore",
      "    return decorator",
      "    ${0:pass}"
    ],
    "description": "Decorator function with type hints and error handling"
  },

  "Generator Function": {
    "prefix": "generator",
    "body": [
      "from typing import Generator, ${1:Optional, Any}",
      "",
      "def ${2:generator_name}(${3:parameter}: ${4:type}) -> Generator[${5:yield_type}, ${6:send_type}, ${7:return_type}]:",
      "    \"\"\"${8:Generator description}",
      "    ",
      "    Args:",
      "        ${3:parameter} (${4:type}): ${9:Parameter description}",
      "    ",
      "    Yields:",
      "        ${5:yield_type}: ${10:Yield description}",
      "        ",
      "    Returns:",
      "        ${7:return_type}: ${11:Final return value}",
      "    \"\"\"",
      "    ${12:# Generator logic}",
      "    for ${13:item} in ${14:iterable}:",
      "        try:",
      "            ${15:# Process item}",
      "            ${16:processed_item = process(item)}",
      "            yield ${16:processed_item}",
      "        except Exception as e:",
      "            ${17:# Handle exception}",
      "            ${18:logging.warning(f\"Error processing {item}: {e}\")}",
      "            continue",
      "    ",
      "    return ${19:final_value}",
      "    ${0:pass}"
    ],
    "description": "Generator function with proper type hints and error handling"
  },

  "Enum Class": {
    "prefix": "enum",
    "body": [
      "from enum import Enum, auto",
      "from typing import ${1:Optional}",
      "",
      "class ${2:EnumName}(Enum):",
      "    \"\"\"${3:Enum description}",
      "    ",
      "    This enum represents ${4:what it represents}.",
      "    \"\"\"",
      "    ",
      "    ${5:VALUE1} = ${6:\"value1\"}",
      "    ${7:VALUE2} = ${8:\"value2\"}",
      "    ${9:VALUE3} = auto()",
      "    ",
      "    def __str__(self) -> str:",
      "        \"\"\"String representation\"\"\"",
      "        return self.value",
      "    ",
      "    @classmethod",
      "    def from_string(cls, value: str) -> '${2:EnumName}':",
      "        \"\"\"Create enum from string value",
      "        ",
      "        Args:",
      "            value (str): String value to convert",
      "            ",
      "        Returns:",
      "            ${2:EnumName}: Corresponding enum value",
      "            ",
      "        Raises:",
      "            ValueError: If value is not valid",
      "        \"\"\"",
      "        for member in cls:",
      "            if member.value.lower() == value.lower():",
      "                return member",
      "        raise ValueError(f\"'{value}' is not a valid {cls.__name__}\")",
      "        ${0:pass}"
    ],
    "description": "Enum class with utility methods"
  },

  "Logging Setup": {
    "prefix": "logging",
    "body": [
      "import logging",
      "import sys",
      "from typing import Optional",
      "",
      "def setup_logging(",
      "    level: int = logging.INFO,",
      "    format_string: Optional[str] = None,",
      "    log_file: Optional[str] = None",
      ") -> logging.Logger:",
      "    \"\"\"Set up logging configuration",
      "    ",
      "    Args:",
      "        level (int): Logging level",
      "        format_string (Optional[str]): Custom format string",
      "        log_file (Optional[str]): Log file path",
      "        ",
      "    Returns:",
      "        logging.Logger: Configured logger",
      "    \"\"\"",
      "    if format_string is None:",
      "        format_string = (",
      "            '%(asctime)s - %(name)s - %(levelname)s - '",
      "            '%(filename)s:%(lineno)d - %(message)s'",
      "        )",
      "    ",
      "    formatter = logging.Formatter(format_string)",
      "    ",
      "    # Console handler",
      "    console_handler = logging.StreamHandler(sys.stdout)",
      "    console_handler.setFormatter(formatter)",
      "    ",
      "    # Configure root logger",
      "    logger = logging.getLogger(${1:'__name__'})",
      "    logger.setLevel(level)",
      "    logger.addHandler(console_handler)",
      "    ",
      "    # File handler if specified",
      "    if log_file:",
      "        file_handler = logging.FileHandler(log_file)",
      "        file_handler.setFormatter(formatter)",
      "        logger.addHandler(file_handler)",
      "    ",
      "    return logger",
      "",
      "# Usage",
      "logger = setup_logging()",
      "${0:logger.info(\"Logging setup complete\")}"
    ],
    "description": "Comprehensive logging setup with console and file output"
  },

  "Command Line Interface": {
    "prefix": "argparse",
    "body": [
      "import argparse",
      "import sys",
      "from typing import Optional, Sequence",
      "",
      "def create_parser() -> argparse.ArgumentParser:",
      "    \"\"\"Create and configure argument parser",
      "    ",
      "    Returns:",
      "        argparse.ArgumentParser: Configured parser",
      "    \"\"\"",
      "    parser = argparse.ArgumentParser(",
      "        description='${1:Script description}',",
      "        epilog='${2:Additional help text}',",
      "        formatter_class=argparse.RawDescriptionHelpFormatter",
      "    )",
      "    ",
      "    parser.add_argument(",
      "        '${3:positional_arg}',",
      "        help='${4:Positional argument description}'",
      "    )",
      "    ",
      "    parser.add_argument(",
      "        '-${5:v}', '--${6:verbose}',",
      "        action='store_true',",
      "        help='${7:Enable verbose output}'",
      "    )",
      "    ",
      "    parser.add_argument(",
      "        '-${8:o}', '--${9:output}',",
      "        type=str,",
      "        default='${10:output.txt}',",
      "        help='${11:Output file path} (default: %(default)s)'",
      "    )",
      "    ",
      "    parser.add_argument(",
      "        '--${12:config}',",
      "        type=argparse.FileType('r'),",
      "        help='${13:Configuration file}'",
      "    )",
      "    ",
      "    return parser",
      "",
      "def main(argv: Optional[Sequence[str]] = None) -> int:",
      "    \"\"\"Main entry point",
      "    ",
      "    Args:",
      "        argv: Command line arguments",
      "        ",
      "    Returns:",
      "        int: Exit code",
      "    \"\"\"",
      "    parser = create_parser()",
      "    args = parser.parse_args(argv)",
      "    ",
      "    try:",
      "        ${14:# Main logic}",
      "        if args.${6:verbose}:",
      "            print(f\"Processing: {args.${3:positional_arg}}\")",
      "        ",
      "        ${15:# Your code here}",
      "        ",
      "        return 0",
      "    except Exception as e:",
      "        print(f\"Error: {e}\", file=sys.stderr)",
      "        return 1",
      "",
      "if __name__ == '__main__':",
      "    sys.exit(main())",
      "    ${0:pass}"
    ],
    "description": "Command line interface with argparse"
  }
}
      